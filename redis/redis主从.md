redis的高可用包含两层含义: 1.数据少丢失 2.服务尽量不中断

第一个靠AOF和RDB实现，第二个增加副本冗余量，将一份数据同时保存在多个实例上，即使有一个实例出现了故障，也可以由其他实例的副本保证服务。

**Redis提供了主从库模式，以保证数据副本的一致性，主从库之间采用的读写分离**

读操作: 主库，从库都可以接受

写操作: 首先到主库执行，然后，主库将写操作同步给从库

## 主从同步之主库正常（全量复制-命令传播-增量复制）

### 主从库间的第一次同步 - 全量复制

启动多个redis实例，通过replicaof形成主库和从库之间的关系

例如：实例1 ip:111.111.111 和实例2 ip:222:222:222, 在实例2执行以下命令

```
replicaof 111.111.111 6379
```

实例2就成了实例1的从库，并从实例1复制数据

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/BD6390DF-8816-4377-B02B-D735006EF91E.png)

#### 第一阶段是主从库建立连接，协商同步的过程 主要为全量复制做准备。

从库给主库发送psync命令，表示进行数据同步，主库根据psync命令的参数启动复制。

psync包含两个参数主库runID和复制进度offset两个参数：

**runID**: 每个Redis实例启动时都生成一个随机id，来标记这个实例。当从库和主库第一次复制时，因为不知道主库的runID，所以runID 设置为？

**offset**: 此时设置为-1，表示第一次复制

主库收到命令后会带上折两个参数，**FULLRESYNC表示第一次采用全量复制**。

#### 第二阶段 主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载，主要依赖于内存快照生成的RDB文件

主库执行bgsave命令，生成rdb文件，接着将文件发给从库。从库接收到RDB文件后，会清空当前数据库，然后加载RDB文件.

主库同步过程中正常服务时不会阻塞的，为了保证主从库的一致性，主库会在内存中生成专门的replication buffer,记录RDB文件生成后收到的所有写操作

#### 第三阶段 发送repl buffer给从库

### 完成首次复制后的同步 - 基于长连接的命令传播 

完成全量复制后，主从之间就会维护起一个网络连接，主库会通过这个连接陆续把收到的命令操作同步给从库，长连接避免频繁建立连接的开销

### 一些会遇到的问题

**1.从库很多时，采用主从级联模式分担全量复制时的主库压力，通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上**

```
repliacof 所选从库IP 6379
```

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/FAF3EFBB-4E2F-47BE-BA8B-04DF9F5529F2.png)

**2.主从库间网络发生中断**

redis2.8后，网络中断后会继续把收到的写操作写入 replication buffer, 同时会把这些操作命令也写入**repl_backlog_buffer** 这个缓冲区

**repl_backlog_buffer**是一个环形缓冲区，主库会记录自己写到的位置, 从库则会记录自己已经读到的位置

刚开始位置在一起, 各自通过参数记录自己的偏移量。主库偏移量:master_repl_offset;从库偏移量:slave_repl_offset

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/25293216-6B4B-4829-A2C2-352FEADC1AB7.png)

连接恢复过程如下：

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/5FB49473-E3EF-4409-9BB2-39AFCAB0CEB8.png)

**repl_backlog_buffer是一个环形缓冲区，写满后主库会覆盖写入，如果从库读取慢或者网络恢复慢从库就会丢失数据**

因此需要调整缓冲区的大小 **repl_backlog_size**

**缓冲计算公式:repl_backlog_size = （主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小）* 2**

为了应付一些突发的请求压力所以repl_backlog_size需要X2，如果这样还有问题就需要用到**切片集群**

## 主从同步之主库异常（哨兵机制）

哨兵时运行在特殊模式下的Redis进程，主从库实例运行的同时，也在运行。

主要负责三个任务：监控，选主和通知

在哨兵进程运行时，周期性地给所有的主从库发送PING命令，检测他们是否仍然是否在线运行。如果没有没有在规定的时间内响应哨兵的ping命令，哨兵就会把它标记下线。如果是主库下线，就开始执行主库切换的流程。以下是基础过程：

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/3A11B7AF-A944-440F-AC55-D0AEC650674D.png)

**哨兵的主要任务:**

* 判断主库是否处于下限状态
* 在众多从库中选择合适的成为新的主库
* 将主库信息发送给从库以及客户端

### 判断主库下线

**主观下线**:Ping命令没有正常返回，标记为主观下线

**客观下线**:减少主观下线带来的误判（主库压力大，网络拥塞），采用多实例组成的集群模式进行部署（哨兵集群）引入多个哨兵实例一起判断。

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/26E09A1D-626A-447B-9CE6-CFBCB6352B43.png)

标准一般是（可自主配置）: 当有N个实例时，N/2 + 1个实例判断主库为主观下线，此时为客观下线开始执行切换操作



### 选主库

1.检查在线状态，检查网络连接状态

不在线直接过滤

连接状态相关配置:

```
down-after-miliseconds * 10 # down-after-miliseconds 超时时间 10 次数 超过次数过滤
```

2.进行打分

**第一轮:优先级**

```
slave-priority #配置从库优先级
```

**第二轮:和旧主库同步接近**

环形缓冲区的标志位 slave_repl_offse和master_repl_offset

**第三轮:ID号小的从库优先**



## 哨兵集群

相关配置

```
sentinel monitor <master-name> <ip> <redis-port> <quorum>
```

### 基于pub/sub（发布/订阅） 机制的哨兵集群组成

**1.哨兵间的相互沟通**

哨兵只要和主库建立了连接，就可以在主库上发布消息了，比如ip和端口号 这样就可以建立连接

我们自己编写的应用程序也也可以通过R edis进行消息的发布和订阅

redis会以频道的的形式，对这些消息进行分门和分类

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/9CF056AE-8C91-4D18-AAC0-47876C1D5540.png)

**哨兵不仅需要在哨兵之间建立网络连接， 还需要和从库建立连接。监控任务中心跳检测，主从切换后通知主从同步**



**2.哨兵如何获取从库信息IP地址和端口**

**哨兵向主库发送INFO命令来完成。**

哨兵给主库发送INFO命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续的对从库进行监控

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/9F312B3F-E8A7-4160-97F5-29876C01715C.png)



### 基于pub/sub（发布/订阅） 机制的客户端事件通知

本质上哨兵是一个运行在特定模式下的Redis实例，不为请求操作服务之完成监控，选主和通知的任务。所以哨兵也提供了很多消息订阅频道，不同频道包含了主从切换过程中的不同关键事件。

主要频道:

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/DF5FC98B-D043-48B7-9A4E-D914113DAE74.png)

**具体操作，客户端读取哨兵的配置文件，与哨兵建立网络连接。接着就可以执行命令订阅频道**

```
SUBSCRIBE +odown # 订阅主观下线
```

```
SUBSCRIBE * #订阅全部
```

当哨兵把新主库选择出来后，客户端就会看到switch-master事件

```
switch-master <master-name> <oldip> <oldport> <newip> <newport>
```

客户端就可以用新的ip进行通信了

### 如何决定由哪个哨兵执行切换任务

任何一个实例只要自身判断主库主观下线，就会给其他实例发送is-master-down-by-addr.

他实例开始根据自身和主库的状态给出N/Y

此哨兵发出命令，表明自己成为leader，执行切换，条件如下：

1.拿到半数以上的Y

2.Y大于等于配置文件中的quorum值

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/E3B3CF45-B3A8-4270-9892-F0BB5E6B2E40.png)



## 切片集群

数据量变大时的扩容方案：

纵向扩展:升级单个Redis实例的资源配置,在不需要rdb的情况下

​				优点:简单

​				缺点:RDB下fork阻塞，金钱成本高

横向扩展:横向增加redis实例的个数

​				优点：金钱成本低

​				缺点：比较复杂

在使用RDB进行持久化时，redis会fork子进程来完成，fork操作的用时和redis的数据量时正相关的，而fork在执行时会阻塞主线程。

这时候就需要切片集群，也叫分片集群，指启动多个redis实例组成一个集群，然后按照一定规则，把收集到的数据分成多份，每一份用一个实例来保存。

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/EBB95FBD-6974-4265-BAC4-C08C7BEEB295.png)



### **数据切片和实例的对应分布关系**

切片集群是一种保存大量数据的通用机制，这个机制由不同的实现方案。

从3.0开始，官方提供了一个名为Redis Cluster的方案，用于实现切片集群。方案中规定了数据和实例的对应规则。

**采用哈希槽(hash slot),来处理数据和实例之间的关系。一个切片集群中共有16384个哈希槽，类似于数据分区，每个键值对都会根据它的key,被映射到一个哈希槽中**

**映射过程:**

1.根据键值对的keys,按照CRC16算法计算一个16bit的值，然后对16384取模，得到0～16383范围内的模数

2.在部署Redis Cluster方案时，可以使用**cluster create**命令创建集群，redis会自动把这些槽平均分布在集群实例上。

   也可以使用**cluster meet**命令手动建立实例间的连接，形成集群，再使用**cluster addslots**命令，指定每个实例上的slot个数

**例子:**

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/42D27885-DA92-4DC5-AEE2-9DF146593B3F.png)

图中集群一共有3个实例，同时设有5个哈希槽，通过下面命令手动分配哈希槽:

```
redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1
redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3
redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4
```

**在手动分配哈希槽时需要，需要把16384个槽都分配完,否则Redis集群无法正常工作**



### 客户端定位数据

redis实例会把自己的哈希槽信息发送给和它相连接的实例，来完成哈希槽分配信息的扩散。

 客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。

客户端收到hash槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。

在集群中，实例和哈希槽的对应关系并不是一成不变的：

1.在集群中，实例有新增和删除，redis需要重新分配hash槽

2.为了负载均衡，redis需要把hash槽在所用实例上重新分布一遍

实例之间可以相互传递消息，但是客户端无法感知，Redis Cluster提供了**重定向机制**

**重定向**:客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。

迁移完成:

```
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
```

迁移未完成：

```
GET hello:key
(error) ASK 13320 172.16.19.5:6379
```



