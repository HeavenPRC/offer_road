## OS

#### 1.五种IO模型

阻塞IO，非阻塞IO，IO多路复用，信号驱动式IO，异步非阻塞IO

**阻塞IO**：执行send和recevie（等待数据和拷贝数据）时对进程进行阻塞操作，知道返回结果，超时或出错才取消阻塞

**非阻塞IO**：内核收到系统调用，再收到进程的read操作后，未完成不会阻塞会返回一个error；用户进程需要不断的主动询问kernel数据准备好了没有；

**IO多路复用：**解决非阻塞IO需要循环访问占用CPU时间的问题，select，poll，epoll 一个线程保存多个socket，轮询监控读写IO。虽然会发生阻塞但不会阻塞在io上，是阻塞在函数上。一个socket的阻塞不会影响其他的socket的Io读写。

**信号驱动式IO：**首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，用户进程再调用I/O操作函数处理数据。

**异步非阻塞IO：**异步IO不是顺序执行。`用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情`。等到socket数据准备好了，内核直接复制数据给进程无序用户进程调用IO操作，`然后从内核向进程发送通知`。`IO两个阶段，进程都是非阻塞的`。

#### 2.select/poll/epoll的区别

|              | select                                                       | poll                   | epoll                                       |
| ------------ | ------------------------------------------------------------ | ---------------------- | ------------------------------------------- |
| 打开句柄数量 | 句柄集合是一个数据，调用select需要全部拷贝，内核做了限制1024 | 用链表储存没有大小限制 | 一个文件描述符管理多个描述符,数量远大于1024 |
| 内存         | 每次调用select，都需要把`fd_set`集合从用户态拷贝             | 和select一样           | 内存映射共用一块内存                        |
| 操作         | 内核要对所有fd_set进行遍历，如果`fd_set`集合很大时，那这个开销也很大， | 和select一样           | 回调函数，活跃的socket才会触发              |

