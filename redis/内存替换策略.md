### 一.设置redis内存大小

```
CONFIG SET maxmemory 4gb
```

### 二.淘汰策略

![avatar](https://static001.geekbang.org/resource/image/04/f6/04bdd13b760016ec3b30f4b02e133df6.jpg)

#### 

#### 1. random:随机删除

#### 2. Lru: LRU算法 

所有数据组织成一个链表，最近访问的在MRU端，否则在LRU端

![avatar](https://static001.geekbang.org/resource/image/02/y5/0201f85c84203300ae4085c60e955yy5.jpg)

##### LRU算法问题

LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会**降低 Redis 缓存性能**。

##### REDIS对LRU的优化

在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，

* 第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。

Redis 提供了一个配置参数 maxmemory-samples，这个参数就是 Redis 选出的数据个数 N。例如，我们执行如下命令，可以让 Redis 选出 100 个数据作为候选数据集：

```
CONFIG SET maxmemory-samples 100
```

* 再次淘汰时，进入候选集合的数据LRU字段值必须小于候选集合中最小的LRU值

#### 使用建议：

* **优先使用 allkeys-lru 策略**。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。
* 如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。
* **有置顶的需求**，比如置顶新闻、置顶视频，使用 volatile-lru 

#### 3. lfu:LFU算法

####  4. ttl: 越快过期越先被淘汰

### 三.淘汰数据处理

干净页直接删除，脏页需要刷入数据库,对于redis来说它不知道，需要注意。

![avatar](https://static001.geekbang.org/resource/image/95/5e/953e48912yy9515abf9db588d447cc5e.jpg)

