## 索引的应用

### 普通索引和唯一索引的选择

#### 查询过程

效率上唯一索引稍微微优于普通索引，B+树上数据读取按页读， 再在页上做二分查找

#### 更新过程

##### change buffer

change buffer: 当需要一个数据页时，如果数据页在内存中直接更新，而如果数据页不在内存中，不影响数据一致性的前提下，innoDB会将这些更新操作缓存在change buffer中。change buffer是可以持久化的，叫做merge。

触发merge的行为：

* 访问到和数据相关的数据页面
* 后台线程定期merge
* 数据库正常关闭过程

对于唯一索引，所有更新都要判断操作是否违反约束，需要把数据页读入内存才能判读，所以不需要change buffer。因此只有普通索引使用。

change buffer使用的是buffer pool里的内存·

````
innodb_change_buffer_max_size #来动态设置
````

* 当记录在buffer pool中，差别仅仅是一个判断（因为索引数据都是有序储存）
* 当记录不在buffer pool中，唯一索引就多了一个读磁盘IO操作，普通索引直接放入change buffer

##### change buffer使用场景

change buffer 适用于写多读少的库，merge前change buffer中数据越多收益越大，读频繁的反而会增加change buffer的维护成本

##### change buffer和redo log

![avatar](https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png)

![avatar](https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png)

Redo log主要节省的是随机写磁盘的IO消耗，change buffer主要节省的则是随机读磁盘的IO消耗

#### 选择和应用

* 性能角度考虑，尽量选择普通索引

* 所有更新后面都跟着数据的查询，应该关闭change buffer

* 如果读少的库，change buffer应该火力全开，最大是buffer pool的50%

  

### 数据库选择索引的机制

优化器判断因素：

#### 扫描行数

* 一个索引上不同的值越多，这个索引的区分度就越好。一个索引上不同值的个数叫做**基数**

* mysql通过采样随机取出N个数据页进行分析，然后进行计算。
* 当变更数据行操作1/M的时候，会自动触发统计
* 回表

```
# on 统计信息持久储存 N 20 M 10
# off 储存在内存中 N 8 M 16
innodb_stats_persistent [on|off]
```

有时侯对扫描行树错误的判断，会导致优化器选择索引错误。

```
全表扫描聚集索引的数据行数
普通索引 show table status
```

#### 是否使用临时表

#### 是否排序

临时表>排序>扫描行数

 解决方案

* Force index 强制选择索引
* analyze # 重新统计扫描行数
* 修改语句改变mysql的索引使用
* 新建一个合适的索引或者删掉不用的索引

## flush脏页

**脏页：**和磁盘数据页内容不一致的内存数据页

**干净页：**和磁盘数据内容一致的叫做干净页

在flush脏页时，数据库就有可能会变慢

### 触发flush的场景

1.redo log已经写满

2.系统内存不足，需要淘汰掉一部分内存页，如果淘汰掉的内存页时脏页，就需要把数据刷到磁盘中

3.数据库正常关闭

### 刷脏页影响性能的情况

* 一个查询要淘汰掉的脏页个数太多，会导致查询的响应时间明显变长
* 日志写满，更新会全部堵住，写性能为0ß

### InnoDB刷脏页的控制策略

1.正确告诉innodb磁盘读写能力

```
innodb_io_capacity # 用来通知innoDB 磁盘的读写能力
```

测试磁盘读写能力的命令·：

```
fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 
```

2.不要让脏页比例靠近75%

3.相邻数据页时脏页页会被刷掉,可以通过以下参数控制行为

```
innodb_flush_neighbors 0 表示只刷自己
```

## 表空间回收

表数据可以放在共享表空间也可以是.ibd为后缀的文件

```
Innodb_fike_pre_table  # on 默认配置文件存储 off 共享表空间
```

删除表 文件储存会直接删除 但是表空间不会立即回收

### 数据删除流程

**行删除时**，不会删掉只会标记行为删除，新增对应位置的数据可能会复用这个位置。磁盘文件的大小并不会缩小。

行的复用只局限于符合范围条件的数据

**页删除时**，整个数据页可以被复用

可以复用于任何位置

当相邻的两个数据页利用率太小，数据会合并到一个数据页上，另外一个数据页标记为可复用

**删除整个表数据**，所有的数据页被标记为可用，磁盘文件并不会变小

### 数据插入流程

如果数据插入是顺序插入的，那么必然就是紧凑的不会有问题。如果是随机写入数据，就有可能造成数据页分裂。

#### 重建表

可以通过

```
alter tabke A engine=InnoDB #这里的MDL锁已经退化成读锁
```

命令来重建表,来进行空间收缩

#### Online DDL （写锁不阻塞数据操作）

流程

1.建立临时文件，扫描表A主键的所有数据页

2.用页表A的记录生成B+树，存储到临时文件中

3.生成临时文件的过程中，将所有对A的操作记录在一个日志文件中

4.临时文件生成后,将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件

5.用临时文件替换原有数据



```
alter table t engine=innodb,ALGORITHM=inplace; # 内部拷贝， server  不可见

alter table t engine=innodb,ALGORITHM=copy; #  临时表拷贝
```



1.DDL. online 一定是inlpace

2.inplace 不一定是online



#### 三种重建表方式的区别

1.alter table t engine=innodb 上面流程

2.analyze table 对索引信息进行统计 MDL读锁

3.optimize table t = 1+2x

