### 1.为什么采用多进程而不采用多线程

nginx为了保证自己的高可靠性和高可用性，

多线程共享内存地址空间，第三方模块或者线程产生一个越界等错误会拖垮nginx，多进程内存空间相互隔离。

### 2.nginx进程构成

**nginx的进程之间都是通过共享内存进行通信**

#### master进程

用来监控管理worker进程

#### worker进程

真正处理请求

cache manager

缓存管理

Cache loader

缓存加载

### 3.worker 进程为什么会有多个

nginx采用事件驱动模型epoll,每个worker从头到尾占用一个cpu，与具体的cpu核绑定，减少缓存命中率。

### 4.父子进程间通过信号管理（命令行kill）

通过master管理worker

reload reopen stop quit

### 5.reload流程

平滑更新配置文件。

1.master 接受hub信号

2.检测语法

3.打开新监听端口（需要打开443）

4.新配置启动新worker进行

5.旧子进程QUIT

6.关闭监听句柄，处理完当前连接然后退出

（请求异常，客户端一直未处理，导致旧进程无法退出，可以配置超时时间）

### 6.热升级-动态库文件升级

1.替换文件

2.向master进程发送USR2信号

3.master进程修改pid文件名，加上后缀.oldbin

4.master启用新进程

5.向老进程发送Quit

6.回滚：向老master发送HUP，向新master发送QUIT

### 7.优雅关闭worker进程的流程（主要针对http）

1.设置定时器worker_shutdown_timeout

2.关闭监听句柄

3.关闭空闲连接

4.在循环中等待全部连接关闭

5.退出进程

### 8.网络事件

TCP流与报文

传输层：添加源端口，目的端口

网络层：源IP地址 目的IP地址

数据链路层：源MAC地址，目的MAC地址



#### 事件收集，分发器

1.请求建立TCP连接 - 读事件

2.TCP连接可读事件 - 读事件

3.TCP连接关闭事件 - 读事件

4.TCP连接可写事件

5.异步读磁盘成功事件

#### 

1.连接建立事件消费者

2.读事件消费者

3.连接关闭消费者

4.异步磁盘读磁盘消费者

5.定时器事件消费者



### 9.Nginx-worker事件循环

1.初始状态处于sleep状态，epoll wait

2.事件进入，唤醒worker进程

3.向kernel请求事件

4.nginx等待事件队列，kernel将准备好的事件队列放入事件队列

4.开始处理事件（中间可能会出现新的事件）



#### 10.epoll

数据结构 红黑树和一个列表



#### 11.网络拥塞时nginx请求切换 请求大的时间片

#### 一个线程处理一个请求

1.不做连接切换

2.依赖OS的的进程调度实现并发

#### 单线程同时处理多连接

用户态代码完成连接切换

尽量减少OS进程切换