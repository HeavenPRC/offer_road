## OS

#### 1.五种IO模型

阻塞IO，非阻塞IO，IO多路复用，信号驱动式IO，异步非阻塞IO

**阻塞IO**：如果accept队列为空，导致用户进程sleep，交出cpu，发生进程间切换

**非阻塞IO**：如果accept队列为空，内核收到系统调用，再收到进程的read操作后，未完成不会阻塞会返回一个error；用户进程需要不断的主动询问kernel数据准备好了没有；不会交出CPU，造成严重的资源耗费

**IO多路复用：**select，poll，epoll 一个线程保存多个socket，轮询监控读写IO。虽然会发生阻塞但不会阻塞在io上，是阻塞在函数上。一个socket的阻塞不会影响其他的socket的Io读写。

最大的优势是：一个用户线程监控多个socket io

**信号驱动式IO：**首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，用户进程再调用I/O操作函数处理数据。

**异步非阻塞IO：**异步IO不是顺序执行。`用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情`。等到socket数据准备好了，内核直接复制数据给进程无序用户进程调用IO操作，`然后从内核向进程发送通知`。`IO两个阶段，进程都是非阻塞的`。

#### 2.select/poll/epoll的区别

|              | select                                                       | poll                   | epoll                                       |
| ------------ | ------------------------------------------------------------ | ---------------------- | ------------------------------------------- |
| 打开句柄数量 | 句柄集合是一个数组，调用select需要全部拷贝，内核做了限制1024 | 用链表储存没有大小限制 | 一个文件描述符管理多个描述符,数量远大于1024 |
| 内存         | 每次调用select，都需要把`fd_set`集合从用户态拷贝到内核       | 和select一样           | Mmap内存映射和内核共用一块内存              |
| 操作         | 内核要对所有fd_set进行遍历，如果`fd_set`集合很大时，那这个开销也很大， | 和select一样           | 活跃的socket才会触发                        |

## 网络

#### 1. 常用状态码

301 永久重定向

302 重定向，禁止缓存

304  （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

401（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应

403  （禁止） 服务器拒绝请求。-权限校验

412  （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。

413  请求实体过大

500 服务内部发生错误-服务发生错误

502 与上游未成功建立连接

503 服务暂时不可用-发生在nginx限流

#### 2. TCP三次握手

客户端主动发起请求会发送一个SYN报文初始序号seq这就是第一次握手，服务器收到后返回一段SYN,ACK报文以及带着自己的初始序列号这是第二次握手，最后客户端返回一个ACK 确认收到收到初始序列号。

##### 不是两次握手的原因

双方都需要确认对方的初始序列号，所以在保证消耗资源最小和保证安全的前提下3次最合适

##### 不主动关闭连接的保活

TCP设有一个保活计时器，服务器每收到一次客户端的请求都会重新复位这个计时器，时间通常设置为两小时，如果两个小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，每隔75秒发送一次。如果一连发送10个探测报文仍然没有反应，服务器认为客户端出了故障，接着就关闭连接

#### 4.TCP 关闭连接的四次挥手

第一次挥手:发送一个FIN带着自己序号seq，表示想要断开连接，进入FIN_WAIT_1（半关闭状态）

第二次挥手:服务器收到后离开ESTABLISHED状态，进入close_wait, 返回ACK 确认自己收到了关闭的请求并检查自己是否还有数据要发送给主动方，客户端进入FIN-WAIT-2

第三次挥手:服务器开始向客户端发送FIN，ACK(表示在收到客户端报文的基础上+1)表示已经准备好释放连接，进入last-ack

第四次挥手:  客户端发送ACK表示收到，进入TIME_WAIT

##### 为什么是四次

服务器接收到请求后，有可能还有未处理完成的请求。

和握手一样是基于seq和ack来做的，双方都需要知道对方收到自己的请求，一但都是报文流程就不可继续

##### 为什么要time_wait等待2MSL（max segment lifetime一段TCP报文在传输过程中的最长生命周期）

这是一个保底机制，最后一次挥手客户端不确定服务器会不会收到报文。

而服务器在1MSL内没有收到ACK报文，就会向客户端重新发送一个ACK报文

#### 3. TCP的状态

**CLOSED**：初始状态，表示TCP连接是“关闭着的”或“未打开的”。

**LISTEN** ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。

**SYN_RCVD** ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。

**SYN_SENT** ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。

**ESTABLISHED** ：表示TCP连接已经成功建立。

**FIN_WAIT_1** ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：

FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。

**FIN_WAIT_2** ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。

**TIME_WAIT** ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）

**CLOSING** ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。

**CLOSE_WAIT** ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。

**LAST_ACK** ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。

#### 4. TIME_WAIT的问题

在高并发场景下，在短时间内业务处理+传输数据的时间远小于TIME_WAIT的时间，导致会有大量的端口被占用导致服务器拒绝为一部分客户服务。

编辑内核文件/etc/sysctl.conf

```
net.ipv4.tcp_syncookies = 1 表示开始SYN cookies, 当SYN等待队列溢出时，启用cookie来处理，可防范少量SYN攻击
net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认0，表示关闭
net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收 默认为0 表示关闭
net.ipv4.tcp_fin_timeout 修改系统默认的TIMEOUT时间
```

```
系统保存TIME_WAIT套接字的最大数量
```

#### 5.http和udp的区别

#### 6.http(1 |1.1|2|3)的区别

## 数据结构（融化于各个细节中）

## 算法

## Nginx

#### 1.nginx如何处理一个请求

首先，nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在nginx的master进程里面，先初始化好这个监控的socket(创建socket，设置addrreuse等选项，绑定到指定的ip地址端口，再listen)，然后再fork(一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程 )出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向nginx发起连接了。当客户端与nginx进行三次握手，与nginx建立好一个连接后，此时，某一个子进程会accept成功，得到这个建立好的连接的socket，然后创建nginx对连接的封装，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，nginx或客户端来主动关掉连接，到此，一个连接就寿终正寝了。

　　当然，nginx也是可以作为客户端来请求其它server的数据的（如upstream模块），此时，与其它server创建的连接，也封装在ngx_connection_t中。作为客户端，nginx先获取一个ngx_connection_t结构体，然后创建socket，并设置socket的属性（ 比如非阻塞）。然后再通过添加读写事件，调用connect/read/write来调用连接，最后关掉连接，并释放ngx_connection_t。

　　nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。并且，nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。

　　在这里，很多人会误解worker_connections这个参数的意思，认为这个值就是nginx所能建立连接的最大值。其实不然，这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。

## Redis

##### 1.Redis 缓存具体是怎么工作的？
##### 2.Redis 缓存如果满了，该怎么办？
##### 3.为什么会有缓存一致性、缓存穿透、缓存雪崩、缓存击穿等异常，该如何应对？
##### 4.Redis 的内存毕竟有限，如果用快速的固态硬盘来保存数据，可以增加缓存的数据量，那么，Redis 缓存可以使用快速固态硬盘吗？

##### 5.Redis连接过高有1w个连接

有可能是大量socket连接之后迅速关闭造成的。

1.redis默认可以打来1w的连接，修改相关配置项,然后平滑重启

```
cd /usr/local/redis/bin 必须进入bin文件
./redis-server /usr/local/redis/etc/redis.conf  配置文件来启动Redis 服务
./redis-cli 启动客服端
127.0.0.1:6379>这个就代表进来了
debug reload 平滑重启
如果有密码就输入密码，密码忘记了就去Redis配置文件找
```

2.查看是否时空闲连接过多不释放

查看链接状态

```
redis-cli client list

addr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client
addr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping
```

查看配置

```
redis-cli config get timeout
```

配置空闲清理

```
redis-cli config set timeout 600
```

3.修改业务代码使用连接池，避免每一个命令打开一个连接或者使用完后主动关闭

## Go&PHP

#### 1. 进程，线程和协程

#### 2.GMP

#### 3.channle

#### 4.GC

## 系统设计

其实就是围绕业务实现，容灾方案，模块化设计，服务监控这几方面说就行