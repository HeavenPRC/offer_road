## 1.OSI和TCP/IP

​		**OSI** 是标准化组织为了实现设备bai互联而提出du的一个纯理论的框架性的概念。也可就是说:它只能告诉我们一个网络应该具备哪些功能，某个功能的实现是在某个层次，但具体的实现技术他是不进行规范的。因为OSI的网络模型标准比较严格，另外推出的时间也相对较晚，所以目前还没有完全按照OSI模型实现的网络。
​		**TCP/IP**是另一种网络模型。是我们实际应用最广泛的一种网络的模型。在这个模型中，不只是划分了功能层，还有具体的实现技术，即协议。TCP和IP就是这个模型中最重要的两个层次的代表协议。
​		这两个模型之间的可以说是完全独立的。因为OSI是一种理论上的指导。而TCP/IP是一种事实上的标准。
​		但两者也是有一定联系的，两者都是网络模型，都存在某些相同的层次。另外，OSI是一个通用性的指导，它不仅可以解释TCP/IP,还可以解释任何一种类型的网络。而tcp/ip是无法解释其他网络的

​		五层体系的协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：物理层、数据链路层、网络层、运输层、应用层。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是TCP/IP四层体系结构。

## 2.对比关系表

| OSI七层模型 | TCP/IP概念模型 | 功能                                   | TCP/IP协议簇                       |
| ----------- | -------------- | -------------------------------------- | ---------------------------------- |
| 表示层      | 应用层         | 文件传输，电子邮件，文件服务，虚拟终端 | TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telnet |
| 应用层      |                | 数据格式化，代码转换，数据加密         |                                    |
| 会话层      |                | 解除与建立与别的节点的联系             |                                    |
| 传输层      | 传输层         | 提供端对端的连接                       | TCP,UDP                            |
| 网络层      | 网际层         | 为数据包选择路由                       | IP,ICMP,RIP,OSPF,BGP,IGMP          |
| 数据链路层  | 网络接口层     | 传输有地址的帧以及错误检测功能         | SLIP,CSLIP,PPP,ARP,RARP,MTU        |
| 物理层      |                | 以二进制数据形式在物理媒体上传输数据   |                                    |



## 3.UDP

#### 包头

源端口号，目标端口号，UDP长度，UDP校验和，数据

#### 特性

无状态，面向字节流，不保证丢包，顺序传输，网络阻塞

沟通简单，不建立连接可广播发送，无拥塞控制

#### 使用场景

1.使用资源少，网络好，对丢包不敏感的应用 eg:DHCP, TFTP

2.不需要一对一沟通，建立连接，而是可以广播的应用

3.需要处理速度快，时延低，可以容忍少数丢包，抢占宽带

#### 例子

网页或者 APP 的访问 QUIC , 流媒体的协议RTMP， IoT 物联网， 移动通信领域



## 4.TCP协议

TCP是面向连接的，保证顺序，不丢包，维护连接，流量控制，拥塞控制

#### *TCP包头格式*

![642947c94d6682a042ad981bfba39fbf](/Users/zhangjian/Desktop/offer_road/642947c94d6682a042ad981bfba39fbf.jpg	

​		源端口号 16位

​		目的端口号 16位

​		序号 32位  :  解决包发送的乱序

​		确认序号 32位 : 发出的包需要确认是否送达 

​		首部长度

​		窗口大小

#### *建立连接 “三次握手”*

![c067fe62f49e8152368c7be9d91adc08](/Users/zhangjian/Desktop/offer_road/c067fe62f49e8152368c7be9d91adc08.jpg)

TCP连接握手，握的是啥？是通信双方数据原点的序列号  Initial sequence number 双方都需要确人对方收到了自己的初始序列号

##### 为什么是“三次握手”，不是两次握手. 

​        1.A SYN -> B

​        2.B SYN+ACK -> A

​		两次握手只能确认A和B就A的初始序号，第二次没有返回就不能确认A和B就B的初始序号，简单来说双方都需要确认对方收到了自己的初始信号

​		防止了客户端失效的连接请求报文段突然又传到服务器，减少了资源的浪费，三次握手是一种能应对网络不稳定情况的最简方案

##### 建立了连接，但是客户端发生故障怎么办

​		TCP设有一个保活计时器，服务器每收到一次客户端的请求都会重新复位这个计时器，时间通常设置为两小时，如果两个小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，每隔75秒发送一次。如果一连发送10个探测报文仍然没有反应，服务器认为客户端出了故障，接着就关闭连接



#### ***断开连接 “四次挥手”***

TCP时全双工通信 两端都可以发送和接收报文

TODO 时序图补充

**1>**第一次挥手

主动方发送并断开连接的请求(即FIN报文)给被动方时，仅仅代表主动方不会再主动发送报文，但是还**可以接收数据报文**

**2>**第二次挥手

被动方此时有可能还有相应的数据报文需要发送ACK报文，告知主动方。主动方不会因为没收到应答继续发送

**3>**第三次挥手

被动方处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。

**4>**第四次挥手

如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。

第四次挥手时主动方发送ACK会进入TIME_WAIT等待2MSL  (**MSL 是 Maximum Segment Lifetime，报文最大生存时间**)

##### 为什么是等待2MSL?

​		1.目的是保证B发出的包全部**dead**不会因为主动方释放端口导致数据包传入新应用防止产生混乱, 	

​		2.然后就是防止ACK被动方收不到留出足够的时间让被动方重新发送

#### ***如何保证顺序和可靠性***

为了保证顺序性，每一个包都有一个ID 在建立连接的时候会商定起始的ID，按照ID顺序一个一个发送。

为了不丢包采用**累计应答|累计确认**，对于发送的包都要进行应答，统一应答表示都收到了



为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分。

第一部分：发送了并且已经确认的。

第二部分：发送了并且尚未确认的。

第三部分：没有发送，但是已经等待发送的。

第四部分：没有发送，并且暂时还不会发送的。



#### ***如何进行流量控制***

TCP中接收端会给发送端报一个窗口大小 Advertised window。窗口大小等于上节分包的第二部分+第三部分（已发送未确认+未发送等待发送），超过这个限制的放在第四部分