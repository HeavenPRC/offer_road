redis的高可用包含两层含义: 1.数据少丢失 2.服务尽量不中断

第一个靠AOF和RDB实现，第二个增加副本冗余量，将一份数据同时保存在多个实例上，即使有一个实例出现了故障，也可以由其他实例的副本保证服务。

**Redis提供了主从库模式，以保证数据副本的一致性，主从库之间采用的读写分离**

读操作: 主库，从库都可以接受

写操作: 首先到主库执行，然后，主库将写操作同步给从库

## 主从同步之主库正常（全量复制-命令传播-增量复制）

### 主从库间的第一次同步 - 全量复制

启动多个redis实例，通过replicaof形成主库和从库之间的关系

例如：实例1 ip:111.111.111 和实例2 ip:222:222:222, 在实例2执行以下命令

```
replicaof 111.111.111 6379
```

实例2就成了实例1的从库，并从实例1复制数据

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/BD6390DF-8816-4377-B02B-D735006EF91E.png)

#### 第一阶段是主从库建立连接，协商同步的过程 主要为全量复制做准备。

从库给主库发送psync命令，表示进行数据同步，主库根据psync命令的参数启动复制。

psync包含两个参数主库runID和复制进度offset两个参数：

**runID**: 每个Redis实例启动时都生成一个随机id，来标记这个实例。当从库和主库第一次复制时，因为不知道主库的runID，所以runID 设置为？

**offset**: 此时设置为-1，表示第一次复制

主库收到命令后会带上折两个参数，**FULLRESYNC表示第一次采用全量复制**。

#### 第二阶段 主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载，主要依赖于内存快照生成的RDB文件

主库执行bgsave命令，生成rdb文件，接着将文件发给从库。从库接收到RDB文件后，会清空当前数据库，然后加载RDB文件.

主库同步过程中正常服务时不会阻塞的，为了保证主从库的一致性，主库会在内存中生成专门的replication buffer,记录RDB文件生成后收到的所有写操作

#### 第三阶段 发送repl buffer给从库

### 完成首次复制后的同步 - 基于长连接的命令传播 

完成全量复制后，主从之间就会维护起一个网络连接，主库会通过这个连接陆续把收到的命令操作同步给从库，长连接避免频繁建立连接的开销

### 一些会遇到的问题

**1.从库很多时，采用主从级联模式分担全量复制时的主库压力，通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上**

```
repliacof 所选从库IP 6379
```

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/FAF3EFBB-4E2F-47BE-BA8B-04DF9F5529F2.png)

**2.主从库间网络发生中断**

redis2.8后，网络中断后会继续把收到的写操作写入 replication buffer, 同时会把这些操作命令也写入**repl_backlog_buffer** 这个缓冲区

**repl_backlog_buffer**是一个环形缓冲区，主库会记录自己写到的位置, 从库则会记录自己已经读到的位置

刚开始位置在一起, 各自通过参数记录自己的偏移量。主库偏移量:master_repl_offset;从库偏移量:slave_repl_offset

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/25293216-6B4B-4829-A2C2-352FEADC1AB7.png)

连接恢复过程如下：

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/5FB49473-E3EF-4409-9BB2-39AFCAB0CEB8.png)

**repl_backlog_buffer是一个环形缓冲区，写满后主库会覆盖写入，如果从库读取慢或者网络恢复慢从库就会丢失数据**

因此需要调整缓冲区的大小 **repl_backlog_size**

**缓冲计算公式:repl_backlog_size = （主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小）* 2**

为了应付一些突发的请求压力所以repl_backlog_size需要X2，如果这样还有问题就需要用到**切片集群**

## 主从同步之主库异常（哨兵机制）

哨兵时运行在特殊模式下的Redis进程，主从库实例运行的同时，也在运行。

主要负责三个任务：监控，选主和通知

在哨兵进程运行时，周期性地给所有的主从库发送PING命令，检测他们是否仍然是否在线运行。如果没有没有在规定的时间内响应哨兵的ping命令，哨兵就会把它标记下线。如果是主库下线，就开始执行主库切换的流程。以下是基础过程：

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/3A11B7AF-A944-440F-AC55-D0AEC650674D.png)

**哨兵的主要任务:**

* 判断主库是否处于下限状态
* 在众多从库中选择合适的成为新的主库

### 判断主库下线

**主观下线**:Ping命令没有正常返回，标记为主观下线

**客观下线**:减少主观下线带来的误判（主库压力大，网络拥塞），采用多实例组成的集群模式进行部署（哨兵集群）引入多个哨兵实例一起判断。

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/26E09A1D-626A-447B-9CE6-CFBCB6352B43.png)

标准一般是（可自主配置）: 当有N个实例时，N/2 + 1个实例判断主库为主观下线，此时为客观下线开始执行切换操作



### 选主库

1.检查在线状态，检查网络连接状态

不在线直接过滤

连接状态相关配置:

```
down-after-miliseconds * 10 # down-after-miliseconds 超时时间 10 次数 超过次数过滤
```

2.进行打分

**第一轮:优先级**

```
slave-priority #配置从库优先级
```

**第二轮:和旧主库同步接近**

环形缓冲区的标志位 slave_repl_offse和master_repl_offset

**第三轮:ID号小的从库优先**



## 哨兵集群

相关配置

```
sentinel monitor <master-name> <ip> <redis-port> <quorum>
```

### 基于pub/sub（发布/订阅） 机制的哨兵集群组成

**1.哨兵间的相互沟通**

哨兵只要和主库建立了连接，就可以在主库上发布消息了，比如ip和端口号 这样就可以建立连接

我们自己编写的应用程序也也可以通过R edis进行消息的发布和订阅

redis会以频道的的形式，对这些消息进行分门和分类

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/9CF056AE-8C91-4D18-AAC0-47876C1D5540.png)

**哨兵不仅需要在哨兵之间建立网络连接， 还需要和从库建立连接。监控任务中心跳检测，主从切换后通知主从同步**



**2.哨兵如何获取从库信息IP地址和端口**



## 切片集群

