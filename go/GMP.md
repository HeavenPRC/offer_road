## goroutine

源码位置:runtime/runtime2.go

go搭建了一个特有的两级线程模型；不使用共享内存的方式来通信，应该以通信来作为手段共享内存；

把数据放在共享内存中让多个线程进行访问，在思想上很简单，但是在并发访问控制上很复杂。

**所以go推介使用channel来在多个goroutine中进行数据传输**

**当然go也提供了传统的同步方式互斥量和条件变量**



**M**:machine 一个M代表一个内核线程，或者“工作线程”

**P**: processor 一个P代表执行一个Go代码片段所必须的资源（或称为“上下文环境”也可以说是调度器）

**G**:gorountione 一个G代表一个Go片段。前者是对后者的一种封装

* 一个G的运行需要M和P的支持
* 一个M和P关联后就形成了一个有效的G运行环境（内核环境和上下文环境）
* 每个P都会包含一个可运行的G队列

### M

```go
type m struct {
  g0       *g       // 在go启动之时创建，用于执行一些运行时任务
  mstartfn func()   // 在新的M上启动某个特殊任务的函数；系统监控 GC辅助 M自旋
  curg     *g       // 当前正在运行g的指针 
  p        puintptr // 指向与当前M关联的P
  nextp    puintptr // 指向与当前M有潜在关联的P
  spinning bool     // 表示M是否正在寻找可运行的G
  lockedg  *g       // 与当前M锁定的g
}
```

#### M的创建

* m开始创建，加入全局M列表，起始函数和预关联的P会被设置；
* 起始函数仅在这个M进行系统监控或者垃圾回收等任务才会被设置
* 运行时系统为M专门创建一个新的内核线程并关联
* 全局M列表，可以让运行时系统获取到所有的M信息，同时也可以防止M被当作垃圾回收掉

#### M的初始化

* 运行时系统开始进行初始化，包括自身所持的栈空间以及信号处理方面的初始化
* 开始执行m起始函数
  * 如果是系统监控函数，会一直执行。不会走下面的流程
  * 当前M与预关的P完成关联，并准备执行其他任务
* M会在多处依次寻找可运行的G并运行

运行时M即全局M列表的M有时也会被停止（垃圾回收）

**运行时系统会把它放入调度器的空闲M列表（runtime.sched.midle）需要一个未使用的M时，运行时系统会尝试从该列表中获取**

**M是否空闲，仅以它是否存在与调度器的空闲M列表中为依据**

#### M的设置

10000个， 但是内核本身也不太支持这么多的内核线程同时存在，所以go的限制可以忽略

```
runtime/debug.SetMaxThreads
```

### P

和CPU的进程线程切换类似，Go的运行时系统会让P与不同的M建立或断开连接，以使P中的那些可运行的G能够及时获得运行时机

P的最大数量实际上是对程序中并发运行的G的规模的一种限制。

P的数量即为可运行的G的队列的数量。一个G被起用后，会先被追加到某个P的可运行G队列中，以等待运行时机

* 设置P的个数只能影响P不会影响M和G的个数
* 当M系统调用发生阻塞时，M与P会解绑，如果队列中还有剩余的G尾处理，就会寻找空闲M
* 运行时系统也存在一个调度器的空闲P列表（runtime.sched.pidle），当P不在且可运行G列表为空与任何一个M绑定时就会放入该列表

#### 状态

| 状态     | 含义                                             |
| -------- | ------------------------------------------------ |
| Pidle    | 当前P未和任意M进行绑定                           |
| Prunning | 正在与某个M进行关联                              |
| Psycall  | 此状态当前P中运行的G正在系统调用                 |
| Pgstop   | 运行时系统需要停止调度。（开始状态和垃圾回收时） |
| Pdead    | 表明当前P已经不会再被                            |

新建 - pgstop

准备完成-pidle

建立连接-prunning

进入系统调用-psyscall

丢弃-pdead



非pdead状态的P都会在运行时系统预停止调度时转入pgstop，当重启调度时统一转为pidle。

#### 设置

```
runtime.GOMAXPROCS
```

改变环境变量GOMAXPROCS

默认是CPU数量，上限不能超过硬性限制

### G

| 状态     | 含义          |
| -------- | ------------- |
| Gidle    | 当前G刚被重新 |
| Prunning | 等待          |
|          | 用            |
| Pgsto    |               |
| Pdea     |               |



### 调度器

串行运行时任务：一些任务执行前都需要停止调度，比如GC，panic等

一轮调度：

1.M和G已绑定，停止M，如果G是可运行状态则唤醒执行到结束

2.有串行化执行的任务则先执行

3.寻找一个可运行的G，如果已绑定则唤醒执行。未绑定绑定执行

寻找可运行的G：顺序

1. 执行终结器的G

2. 本地P的可运行G
3. 调度器的可运行G
4. 网络I/O轮询器，去一个G队列表头作为运行返回并把剩下的放入调度器的可运行G
5. 从其他P的可运行G队列获取G（随机）
6. GC标记任务的G
7. 再次从调度器可运行获取

 **如果获取不到，就会让本地P和M解绑，P放入空闲队列**

8. 从全局P列表中每个P的可运行中获取G(返回第6步)

发现有可运行的，就从空闲P队列拿出一个，绑定返回第一阶段重新开始

9. 获取GC

10. 网络Io（与上面有区别的是这里是阻塞读取）

#### 抢占式调度

### 系统检测任务

系统检测运行在一个专用的M上，并且运行在系统栈之上

## Other

### 变更P的最大数量



