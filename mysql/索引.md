## 知识补充

#### 局部性原理与磁盘预读：

```
由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 
当一个数据被用到时，其附近的数据也通常会马上被使用。 
程序运行期间所需要的数据通常比较集中。 
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
```

## 常见模型

#### 哈希表

hash表是一种以键-值存储数据的结构；把值放在数组里，用一个hash算法把key换算成位置，然后把value放在数组的这个位置中

为了解决hash冲突，采用链式储存

**优点：**等值查询，插入数据都很方便

**缺点**：因为不是顺序储存，所以hash索引做区间查询的数独很慢

**适用场景：**只适用于等值查询的场景，比如redis

#### 有序数组

数据有序储存

**优点：**有序数组在等值查询和范围查询场景中的性能非常优秀，仅看查询效率是最好的数据结构

**缺点：**在插入数据时需要移动数据，成本太高

**适用场景：**只适用于静态存储引擎

#### 平衡二叉树（红黑树）：

- **概念**

平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构；

- **特点：**

平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：

（1）非叶子节点只能允许最多两个子节点存在。

（2）每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)；

#### B(B-)树:

```
B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;
（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
（2）子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;
```

![avatar](https://pic2.zhimg.com/80/v2-2c2264cc1c6c603dfeca4f84a2575901_1440w.jpg)



#### B+树：

```
B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。B+ 树通常用于数据库和操作系统的文件系统中。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+ 树元素自底向上插入。

一个m阶的B树具有如下几个特征：

1.根结点至少有两个子女。

2.每个中间节点都至少包含ceil(m / 2)个孩子，最多有m个孩子。

3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m。

4.所有的叶子结点都位于同一层。

5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

```

* **每个叶子节点都有一个指针，指向下一个数据，形成一个有序链表。**

* **只有叶子结点才会保存数据，其他结点都是索引。因为非叶子结点不保存数据所以一个节点可以保存更多的索引数据，减少了磁盘IO**
* **每个节点都存在一个磁盘块中（即一次IO可以取出的数据）**



![avatar](https://upload-images.jianshu.io/upload_images/7862980-42f0acde88d3c0cb.png)

B+tree 其实就是在原有b-tree的基础上。增加两条新的规则

　　1.   Branch节点不能直接查到数据后返回，所有数据必须读穿或写穿到leaf节点后才能返回成功

　　2.   子叶节点的最后一个元素是到下一个leaf节点的指针。

这样做的原因是，更方便做范围查询，在b+树种，如果要查询20~56.只需要找到20这个起始节点，然后顺序遍历，不再需要不断重复的访问branch和root节点了。

```
走进搜索引擎的作者梁斌老师针对B树、B+树给出了他的意见（为了真实性，特引用其原话，未作任何改动）： “B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。 
比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。 
B树比如你的例子中查，17的话，一把就得到结果了， 
有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。 
另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。
```

```
数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。
B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。
正如上面所说，在数据库中基于范围的查询是非常频繁的，因此MySQL最终选择的索引结构是B+树而不是B树。
```

1.是否支持范围查找

　　因为是有序结构，所以能够很好的支持范围查找。

2.集合是否能够随着数据的增长而自动扩展

　　可以，主要增长方式如下： 如果单个数组内还有空隙，那么数据可以直接放入数组内，而如果数组没有空隙，则进行分裂，从而可以支持数据的自动扩展。

3.读写性能如何

　　因为从宏观上可以做到一次排除一半的数据，并且在写入时也没有进行其他额外的数据查找性工作，所以对于b树来说，其读写的时间复杂度都是O(log2n)。 

4.是否面向磁盘结构

　　一般来说，在有内存的情况下，root层和branch里面的一部分都会被缓存在内存中，所以如果树的高度是三层，那么前两层一般都会被缓存在内存中，所以查询基本上只需要一次随机寻道时间， 这比二叉树系列和skiplist系列都要强不少。

5.并行指标

　　b树也是一个并行度比较不错的数据结构，相比较skiplist而言，他很难使用compare and set的方式来进行数据的写入，而必须使用lock来保证读写访问的同步。不过因为可以尽可能的将锁下推，所以锁的颗粒度可以维持在比较小的级别，从而可以提供比较高的并行度。同时，因为b树主要使用的目标场景是磁盘，对于磁盘读写来说，Compare and set 带来的性能提升几乎可以忽略。因此我们可以认为，b树的并行度比skiplist要差，但比其他树的要好

6.内存占用

　　这是b树的一个短板，在最坏的情况下，b树的所有块都刚好做完分裂。那么整棵树需要消耗两倍的空间才能存储下所有的数据，空间相对的有些浪费。所以一般会通过重新平衡的方式加以部分的纠正

## InnoDB索引模型

InnoDB的索引实现分为聚集索引和普通索引

### 聚集索引

```
InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），

InnoDB必须要有至少一个聚簇索引。

由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。
```



### 普通索引













