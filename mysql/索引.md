## 知识补充

#### 局部性原理与磁盘预读：

```
由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 
当一个数据被用到时，其附近的数据也通常会马上被使用。 
程序运行期间所需要的数据通常比较集中。 
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
```

## 常见模型

#### 哈希表

hash表是一种以键-值存储数据的结构；把值放在数组里，用一个hash算法把key换算成位置，然后把value放在数组的这个位置中

为了解决hash冲突，采用链式储存

**优点：**等值查询，插入数据都很方便

**缺点**：因为不是顺序储存，所以hash索引做区间查询的数独很慢

**适用场景：**只适用于等值查询的场景，比如redis

#### 有序数组

数据有序储存

**优点：**有序数组在等值查询和范围查询场景中的性能非常优秀，仅看查询效率是最好的数据结构

**缺点：**在插入数据时需要移动数据，成本太高

**适用场景：**只适用于静态存储引擎

#### 平衡二叉树（红黑树）：

- **概念**

平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构；

- **特点：**

平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：

（1）非叶子节点只能允许最多两个子节点存在。

（2）每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)；

#### B(B-)树:

```
B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;
（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
（2）子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;
```

![avatar](https://pic2.zhimg.com/80/v2-2c2264cc1c6c603dfeca4f84a2575901_1440w.jpg)



#### B+树：

```
B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。B+ 树通常用于数据库和操作系统的文件系统中。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+ 树元素自底向上插入。

一个m阶的B树具有如下几个特征：

1.根结点至少有两个子女。

2.每个中间节点都至少包含ceil(m / 2)个孩子，最多有m个孩子。

3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m。

4.所有的叶子结点都位于同一层。

5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

```

* **每个叶子节点都有一个指针，指向下一个数据，形成一个有序链表。**

* **只有叶子结点才会保存数据，其他结点都是索引。因为非叶子结点不保存数据所以一个节点可以保存更多的索引数据，减少了磁盘IO**
* **每个节点都存在一个磁盘块中（即一次IO可以取出的数据）**



![avatar](https://upload-images.jianshu.io/upload_images/7862980-42f0acde88d3c0cb.png)

B+tree 其实就是在原有b-tree的基础上。增加两条新的规则

　　1.   Branch节点不能直接查到数据后返回，所有数据必须读穿或写穿到leaf节点后才能返回成功

　　2.   子叶节点的最后一个元素是到下一个leaf节点的指针。

这样做的原因是，更方便做范围查询，在b+树种，如果要查询20~56.只需要找到20这个起始节点，然后顺序遍历，不再需要不断重复的访问branch和root节点了。

```
走进搜索引擎的作者梁斌老师针对B树、B+树给出了他的意见（为了真实性，特引用其原话，未作任何改动）： “B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。 
比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。 
B树比如你的例子中查，17的话，一把就得到结果了， 
有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。 
另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。
```

```
数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。
B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。
正如上面所说，在数据库中基于范围的查询是非常频繁的，因此MySQL最终选择的索引结构是B+树而不是B树。
```

1.是否支持范围查找

　　因为是有序结构，所以能够很好的支持范围查找。

2.集合是否能够随着数据的增长而自动扩展

　　可以，主要增长方式如下： 如果单个数组内还有空隙，那么数据可以直接放入数组内，而如果数组没有空隙，则进行分裂，从而可以支持数据的自动扩展。

3.读写性能如何

　　因为从宏观上可以做到一次排除一半的数据，并且在写入时也没有进行其他额外的数据查找性工作，所以对于b树来说，其读写的时间复杂度都是O(log2n)。 

4.是否面向磁盘结构

　　一般来说，在有内存的情况下，root层和branch里面的一部分都会被缓存在内存中，所以如果树的高度是三层，那么前两层一般都会被缓存在内存中，所以查询基本上只需要一次随机寻道时间， 这比二叉树系列和skiplist系列都要强不少。

5.并行指标

　　b树也是一个并行度比较不错的数据结构，相比较skiplist而言，他很难使用compare and set的方式来进行数据的写入，而必须使用lock来保证读写访问的同步。不过因为可以尽可能的将锁下推，所以锁的颗粒度可以维持在比较小的级别，从而可以提供比较高的并行度。同时，因为b树主要使用的目标场景是磁盘，对于磁盘读写来说，Compare and set 带来的性能提升几乎可以忽略。因此我们可以认为，b树的并行度比skiplist要差，但比其他树的要好

6.内存占用

　　这是b树的一个短板，在最坏的情况下，b树的所有块都刚好做完分裂。那么整棵树需要消耗两倍的空间才能存储下所有的数据，空间相对的有些浪费。所以一般会通过重新平衡的方式加以部分的纠正

## InnoDB索引模型

InnoDB的索引实现分为聚集索引和普通索引

### 聚集索引（也叫主键索引）

```
InnoDB的聚簇索引的叶子节点存储的是主键值+行记录（其实是页结构，一个页包含多行数据），

InnoDB必须要有至少一个聚簇索引。

由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。
```

（1）如果表定义了PK，则PK就是聚集索引；

（2）如果表没有定义PK，则第一个not NULL unique列是聚集索引；

（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；

### 普通索引（也叫二级索引）

```
叶子结点记录索引字段值+主键值
```

（1）先通过普通索引定位到主键值id=5；

（2）在通过聚集索引定位到行记录；

这就是所谓的**回表查询**，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。

### 覆盖索引

一个索引覆盖了查询需求，不需要回表，减少了树的搜索次数，显著提升了性能；

查询id: 1, 2, 3, 4中大于等于2小于4时，树会拿到2,3,再比较4，在存储层扫描行数显然是3，在server层则是2，因为他只是找引擎拿了两条数据。

#### 覆盖索引的生效原则

##### 最左前缀原则

![avatar](https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg)

索引key是按照索引字段出现的顺序排列的，只要满足最左前缀就可以快速定位，也可以是联合索引的前N个字段的组合，但是要注意先后顺序。

 比如“李%” “张三” “李四 20”

**建立联合索引的原则：**

1.通过调整顺序可以少维护一个索引，这个索引就是可以优先考虑的

2.考虑空间小的优先， a,b 两个字段a大b小，既有联合查询又有各自的查询，可以建立两个索引（a,b）,(b)而不是其他的

##### 索引下推

在mysql5.6之后，在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### 索引维护

B+树为了维护索引的有序性，

* 在插入新值时。插入数据可能会导致页分裂。页分裂也会导致空间利用率降低约50%
* 在删除数据时，在发现利用率低会进行页合并

使用递增ID作为主键的优点：

* 递增插入，不涉及挪动操作也不会触发叶子结点的分裂
* 主键默认为4字节的整形，比大部分自定义的字段都要短, 也会降低普通索引所占用的空间

当只有一个索引，且这个索引是唯一索引适合用来做主键，没有其他索引也就不用考虑普通索引占用的空间大小

## 索引的应用

### 普通索引和唯一索引的选择

#### 查询过程

效率上唯一索引稍微微优于普通索引，B+树上数据读取按页读， 再在页上做二分查找

#### 更新过程

##### change buffer

change buffer: 当需要一个数据页时，如果数据页在内存中直接更新，而如果数据页不在内存中，不影响数据一致性的前提下，innoDB会将这些更新操作缓存在change buffer中。change buffer是可以持久化的，叫做merge。

触发merge的行为：

* 访问到和数据相关的数据页面
* 后台线程定期merge
* 数据库正常关闭过程

对于唯一索引，所有更新都要判断操作是否违反约束，需要把数据页读入内存才能判读，所以不需要change buffer。因此只有普通索引使用。

change buffer使用的是buffer pool里的内存·

````
innodb_change_buffer_max_size #来动态设置
````

* 当记录在buffer pool中，差别仅仅是一个判断（因为索引数据都是有序储存）
* 当记录不在buffer pool中，唯一索引就多了一个读磁盘IO操作，普通索引直接放入change buffer

##### change buffer使用场景

change buffer 适用于写多读少的库，merge前change buffer中数据越多收益越大，读频繁的反而会增加change buffer的维护成本

##### change buffer和redo log

![avatar](https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png)

![avatar](https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png)

Redo log主要节省的是随机写磁盘的IO消耗，change buffer主要节省的则是随机读磁盘的IO消耗

#### 选择和应用

* 性能角度考虑，尽量选择普通索引

* 所有更新后面都跟着数据的查询，应该关闭change buffer

* 如果读少的库，change buffer应该火力全开，最大是buffer pool的50%

  

### 数据库选择索引的机制

优化器判断因素：

#### 扫描行数

* 一个索引上不同的值越多，这个索引的区分度就越好。一个索引上不同值的个数叫做**基数**

* mysql通过采样随机取出N个数据页进行分析，然后进行计算。
* 当变更数据行操作1/M的时候，会自动触发统计
* 回表

```
# on 统计信息持久储存 N 20 M 10
# off 储存在内存中 N 8 M 16
innodb_stats_persistent [on|off]
```

有时侯对扫描行树错误的判断，会导致优化器选择索引错误。

```
全表扫描聚集索引的数据行数
普通索引 show table status
```

#### 是否使用临时表

#### 是否排序

临时表>排序>扫描行数

 解决方案

* Force index 强制选择索引
* analyze # 重新统计扫描行数
* 修改语句改变mysql的索引使用
* 新建一个合适的索引或者删掉不用的索引















