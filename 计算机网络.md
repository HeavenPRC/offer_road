## 1.OSI和TCP/IP

​		**OSI** 是标准化组织为了实现设备bai互联而提出du的一个纯理论的框架性的概念。也可就是说:它只能告诉我们一个网络应该具备哪些功能，某个功能的实现是在某个层次，但具体的实现技术他是不进行规范的。因为OSI的网络模型标准比较严格，另外推出的时间也相对较晚，所以目前还没有完全按照OSI模型实现的网络。
​		**TCP/IP**是另一种网络模型。是我们实际应用最广泛的一种网络的模型。在这个模型中，不只是划分了功能层，还有具体的实现技术，即协议。TCP和IP就是这个模型中最重要的两个层次的代表协议。
​		这两个模型之间的可以说是完全独立的。因为OSI是一种理论上的指导。而TCP/IP是一种事实上的标准。
​		但两者也是有一定联系的，两者都是网络模型，都存在某些相同的层次。另外，OSI是一个通用性的指导，它不仅可以解释TCP/IP,还可以解释任何一种类型的网络。而tcp/ip是无法解释其他网络的

​		五层体系的协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：物理层、数据链路层、网络层、运输层、应用层。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是TCP/IP四层体系结构。

## 2.对比关系表

| OSI七层模型 | TCP/IP概念模型 | 功能                                   | TCP/IP协议簇                       |
| ----------- | -------------- | -------------------------------------- | ---------------------------------- |
| 表示层      | 应用层         | 文件传输，电子邮件，文件服务，虚拟终端 | TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telnet |
| 应用层      |                | 数据格式化，代码转换，数据加密         |                                    |
| 会话层      |                | 解除与建立与别的节点的联系             |                                    |
| 传输层      | 传输层         | 提供端对端的连接                       | TCP,UDP                            |
| 网络层      | 网际层         | 为数据包选择路由                       | IP,ICMP,RIP,OSPF,BGP,IGMP          |
| 数据链路层  | 网络接口层     | 传输有地址的帧以及错误检测功能         | SLIP,CSLIP,PPP,ARP,RARP,MTU        |
| 物理层      |                | 以二进制数据形式在物理媒体上传输数据   |                                    |

## 3.UDP

#### 包头

源端口号，目标端口号，UDP长度，UDP校验和，数据

#### 特性

无状态，面向字节流，不保证丢包，顺序传输，网络阻塞

沟通简单，不建立连接可广播发送，无拥塞控制

#### 使用场景

1.使用资源少，网络好，对丢包不敏感的应用 eg:DHCP, TFTP

2.不需要一对一沟通，建立连接，而是可以广播的应用

3.需要处理速度快，时延低，可以容忍少数丢包，抢占宽带

#### 例子

网页或者 APP 的访问 QUIC , 流媒体的协议RTMP， IoT 物联网， 移动通信领域



## 4.TCP协议

TCP是面向连接的，保证顺序，不丢包，维护连接，流量控制，拥塞控制

#### *TCP包头格式*

![642947c94d6682a042ad981bfba39fbf](/Users/zhangjian/Desktop/offer_road/642947c94d6682a042ad981bfba39fbf.jpg	

​		源端口号 16位

​		目的端口号 16位

​		序号 32位  :  解决包发送的乱序

​		确认序号 32位 : 发出的包需要确认是否送达 

​		首部长度

​		窗口大小

#### *建立连接 “三次握手”*

![c067fe62f49e8152368c7be9d91adc08](/Users/zhangjian/Desktop/offer_road/c067fe62f49e8152368c7be9d91adc08.jpg)

TCP连接握手，握的是啥？是通信双方数据原点的序列号  Initial sequence number 双方都需要确人对方收到了自己的初始序列号

##### 为什么是“三次握手”，不是两次握手. 

​        1.A SYN -> B

​        2.B SYN+ACK -> A

​		两次握手只能确认A和B就A的初始序号，第二次没有返回就不能确认A和B就B的初始序号，简单来说双方都需要确认对方收到了自己的初始信号

​		防止了客户端失效的连接请求报文段突然又传到服务器，减少了资源的浪费，三次握手是一种能应对网络不稳定情况的最简方案

##### 建立了连接，但是客户端发生故障怎么办

​		TCP设有一个保活计时器，服务器每收到一次客户端的请求都会重新复位这个计时器，时间通常设置为两小时，如果两个小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，每隔75秒发送一次。如果一连发送10个探测报文仍然没有反应，服务器认为客户端出了故障，接着就关闭连接



#### ***断开连接 “四次挥手”***

TCP时全双工通信 两端都可以发送和接收报文

TODO 时序图补充

**1>**第一次挥手

主动方发送并断开连接的请求(即FIN报文)给被动方时，仅仅代表主动方不会再主动发送报文，但是还**可以接收数据报文**

**2>**第二次挥手

被动方此时有可能还有相应的数据报文需要发送ACK报文，告知主动方。主动方不会因为没收到应答继续发送

**3>**第三次挥手

被动方处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。

**4>**第四次挥手

如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。

第四次挥手时主动方发送ACK会进入TIME_WAIT等待2MSL  (**MSL 是 Maximum Segment Lifetime，报文最大生存时间**)

##### 为什么是等待2MSL?

​		1.目的是保证B发出的包全部**dead**不会因为主动方释放端口导致数据包传入新应用防止产生混乱, 	

​		2.然后就是防止ACK被动方收不到留出足够的时间让被动方重新发送

#### ***如何保证顺序和可靠性***

为了保证顺序性，每一个包都有一个ID 在建立连接的时候会商定起始的ID，按照ID顺序一个一个发送。

为了不丢包采用**累计应答|累计确认**，对于发送的包都要进行应答，统一应答表示都收到了



为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分。

第一部分：发送了并且已经确认的。

第二部分：发送了并且尚未确认的。

第三部分：没有发送，但是已经等待发送的。

第四部分：没有发送，并且暂时还不会发送的。



#### ***顺序问题与丢包问题*** （略）

由于网络等问题，包到达不按顺序到达，甚至可能丢包

TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。



#### ***如何进行流量控制*** （略）

TCP中接收端会给发送端报一个窗口大小 Advertised window。窗口大小等于上节分包的第二部分+第三部分（已发送未确认+未发送等待发送），超过这个限制的放在第四部分

接收端以及发送端动态控制窗口大小



#### ***拥塞控制问题***

TCP BBR 拥塞算法



## 5.Socket

基于tcp：

| 客户端      | 服务端                |
| ----------- | --------------------- |
| socket()    | socket()              |
|             | bind() 绑定ip和端口号 |
|             | listen() 监听         |
| connect()-> | accept()              |
| write()->   | read()                |
| read()<-    | write()               |





## 6.HTTP

http是基于tcp连接的



Wireshark 网络抓包工具 能够截获在 TCP/IP 协议栈中传输的所有流量，并按协议类型、地址、端口等任意过滤，功能非常强大

Telnet 是一个经典的虚拟终端，基于 TCP 协议远程登录主机，我们可以使用它来模拟浏览器的行为，连接服务器后手动发送 HTTP 请求，把浏览器的干扰也彻底排除，能够从最原始的层面去研究 HTTP 协议

### HTTP的特征

| 灵活可扩展 | HTTP 协议最初诞生的时候就比较简单，本着开放的精神只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。 |
| ---------- | ------------------------------------------------------------ |
| 可靠传输   | HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。 |
| 应用层协议 | 功能全面                                                     |
| 请求应答   | 请求应答模式 契合C/S B/S RPC等工作模式                       |
| 无状态     | 不存储上下文 每次请求都是独立的每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。 减轻服务器压力也易于做负载均很并发扩展，但是也无法一连串的事务操作 |

### http 1.1的缺点

**明文-不安全**：虽然为开发调试工作带来极大的便利，却也因为明文带来极大的安全隐患

**性能问题**：不算差，不够好；而“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。



### http 1.1的进阶特性

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/http%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD.png)



### HTTPS | SSL/TLS 





**注**: 队头阻塞 - http1.1提出了管线化技术，一次发送多个请求   然而pipelining在接收response返回时，也必须依顺序接收，如果前一个请求遇到了阻塞，后面的请求即使已经处理完毕了，仍然需要等待阻塞的请求处理完毕。这种情况就如图中第三种，第一个请求阻塞后，后面的请求都需要等待

**注：**电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME