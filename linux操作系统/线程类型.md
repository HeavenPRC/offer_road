KSE- 内核调度实体

| 用户级线程模型                                        | 内核级线程模型                                               | 两极线程模型                                                 | Goroutime |
| ----------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------- |
| 存储在用户空间中，内核不参与调度                      | 归属于内核，进程对线程的创建中断终止等都需要进行系统调用     | 一个进程可以绑定多个内核调度实体，进程中线程映射绑定在一个已绑定的KSE上 |           |
| 一个线程发生阻塞所属进程也会被阻塞                    | 可以实现真正的线程并发                                       |                                                              |           |
| 所有线程的优先级对内核不生效，只决定于所属进程（1:N） | 线程的操作的管理都需要占用更多的内核性能，所以创建的数量都有直接或间接的限制(1:1) |                                                              |           |

实现数据一致性的方法

1.临界区

只能被串行化访问或执行的某个资源或代码片段

2.互斥量Mutex

已锁定和未锁定，

离开临界区要解锁，

互斥量属于共享资源，初始化要保证唯一性

1.控制临界区的纯度，不要加杂无关代码

2.控制临界区的粒度，不要太细

3.减少临界区的粒度

4.减少临界区中代码的执行耗时

5.避免长时间持有互斥量

6.优先使用原子操作而不是互斥量

## goroutine

go搭建了一个特有的两级线程模型；不使用共享内存的方式来通信，应该以通信来作为手段共享内存；

把数据放在共享内存中让多个线程进行访问，在思想上很简单，但是在并发访问控制上很复杂。

**所以go推介使用channel来在多个goroutine中进行数据传输**

**当然go也提供了传统的同步方式互斥量和条件变量**



**M**:machine 一个M代表一个内核线程，或者“工作线程”

**P**: processor 一个P代表执行一个Go代码片段所必须的资源（或称为“上下文环境”也可以说是调度器）

**G**:gorountione 一个G代表一个Go片段。前者是对后者的一种封装

* 一个G的运行需要M和P的支持
* 一个M和P关联后就形成了一个有效的G运行环境（内核环境和上下文环境）
* 每个P都会包含一个可运行的G队列

