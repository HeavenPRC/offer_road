## 锁

####  读写锁

共享锁/读锁：多个客户可以在同一时间读取一个资源，互不干扰
排他锁/写锁：一个写锁会阻塞其他对同一资源的读写

#### 锁粒度

表锁：开销最小的策略，锁定整张表，阻塞其他用户对锁定表的读写。
行级锁：锁开销大, 可以最大程度支持并发处理

#### 死锁
死锁是指两个或者多个事物在同一个资源上相互占用， 并请求锁定对方占用的资源进入恶性死循环。
如下两个事物同时操作一张表 :

```
事务1:
      START TRANSACTION;
      UPDATE order SET order_type = 3 WHERE order_id = 1
      UPDATE order SET order_type = 3 WHERE order_id = 2
      COMMIT;
事物2:
      START TRANSACTION;
      UPDATE order SET order_type = 3 WHERE order_id = 2
      UPDATE order SET order_type = 3 WHERE order_id = 1
      COMMIT;
```

# 事务
### 事务

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。

事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。

1.原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
2.一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
3.隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
4.持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

### 事务并发调度带来的问题

1.脏读（dirty read）：A事务读取B事务尚未提交的更改数据，并在这个数据基础上操作。如果B事务回滚，那么A事务读到的数据根本不是合法的，称为脏读。在oracle中，由于有version控制，不会出现脏读。

2.不可重复读（unrepeatable read）：A事务读取了B事务已经提交的更改（或删除）数据。比如A事务第一次读取数据，然后B事务更改该数据并提交，A事务再次读取数据，两次读取的数据不一样。

3.幻读（phantom read）：A事务读取了B事务已经提交的新增数据。注意和不可重复读的区别，这里是新增，不可重复读是更改（或删除）。这两种情况对策是不一样的，对于不可重复读，只需要采取行级锁防止该记录数据被更改或删除，然而对于幻读必须加表级锁，防止在这个表中新增一条数据。

4.第一类丢失更新：A事务撤销时，把已提交的B事务的数据覆盖掉。

5.第二类丢失更新：A事务提交时，把已提交的B事务的数据覆盖掉。

### 数据库事务隔离级别 

注：级别可以通过语句配置SET SESSION TRANSACTION LEVEL READ COMMITTED

SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

#### Read Uncommitted（未提交读）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

#### Read Committed（提交读）

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

#### Repeatable Read（可重复读）

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

#### Serializable（可串行化）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争

### 理解隔离级别的区别：

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/WeChat035a94264bf9d9d3e0fb1946b9a27cc5.png)



* 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
* 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
* 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
* 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

### 隔离级别的实现

在实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。

**读未提交:**直接返回记录的最新值，没有视图概念

**读提交:**视图在每个sql语句开始执行的时候创建

**可重复读:** 视图在事务启动时创建，整个事务存在期间都用这个视图

#### 具体说明可重复读（MVCC）：

MVCC具体有乐观并发控制和悲观并发控制

##### mysql的 MVCC

* 在每条行记录后面保存两个隐藏的列来实现，一个是行的创建时的系统版本号，一个是过期版本号（删除时间）
* 每新开一个事务版本号都会递增，事务开始时刻的系统版本号会作为事务的版本号

具体sql操作，mvcc的操作：

**select**

1. 只会查找版本早于当前事务版本的数据行
2. 行的删除版本要么未定义，要么大于当前事务版本号。确保事务开始前读到的行开始前未被删除

同时满足这两个条件，才可作为查询结果返回

**insert**

插入的每一行保存当前系统版本号作为行版本号

**delete**

删除的每一行保存为当前系统版本号作为删除标识

**update**

 插入一行新记录，保存当前版本号作为保存标识和删除标识



在回滚日志中，每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态值。

当系统没有比这个回滚日志更早的read-view，回滚日志会被删除

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/WeChatdf97d93aa4eb79ad2087a58047373cfe.png)

#### 长事务的缺点：

1.长事务意味着，系统里面要一致保存着很老的事务视图,他可能用到的所有回滚日志都必须保存，就可能占用大量的储存空间

2.长事务还占用锁资源，可能会拖垮整个库

查找长事务 information_schema.innodn_trx

```mysql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```



## 事务的使用

自动提交（AUTOCOMMIT）如果不是显式的开始一个事务， 每个查询都会被当作一个事务执行提交操作

```
查看 SHOW VARITABLES LIKE 'AUTOCOMMIT'
设置启用 SET AUTOCOMMIT = 1 
```
对于非事务类型的引擎可以说是一直处于AUTOCOMMIT启用的模式

**AUTOCOMMIt = 0需要注意，没有显式开启事务的语句，其实也是开启了事务的，只是系统不会主动提交。如果因为失误没有提交可能会导致长事务的产生**

#### 显式锁定
推荐使用的
SELECT ... LOCK IN SHARE MODE
SELECT ...FOR UPDATE
除了事务禁用AUTOCOMMIT不要使用LOCK TABLE

