## 索引的应用

### 普通索引和唯一索引的选择

#### 查询过程

效率上唯一索引稍微微优于普通索引，B+树上数据读取按页读， 再在页上做二分查找

#### 更新过程

##### change buffer

change buffer: 当需要一个数据页时，如果数据页在内存中直接更新，而如果数据页不在内存中，不影响数据一致性的前提下，innoDB会将这些更新操作缓存在change buffer中。change buffer是可以持久化的，叫做merge。

触发merge的行为：

* 访问到和数据相关的数据页面
* 后台线程定期merge
* 数据库正常关闭过程

对于唯一索引，所有更新都要判断操作是否违反约束，需要把数据页读入内存才能判读，所以不需要change buffer。因此只有普通索引使用。

change buffer使用的是buffer pool里的内存·

````
innodb_change_buffer_max_size #来动态设置
````

* 当记录在buffer pool中，差别仅仅是一个判断（因为索引数据都是有序储存）
* 当记录不在buffer pool中，唯一索引就多了一个读磁盘IO操作，普通索引直接放入change buffer

##### change buffer使用场景

change buffer 适用于写多读少的库，merge前change buffer中数据越多收益越大，读频繁的反而会增加change buffer的维护成本

##### change buffer和redo log

![avatar](https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png)

![avatar](https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png)

Redo log主要节省的是随机写磁盘的IO消耗，change buffer主要节省的则是随机读磁盘的IO消耗

#### 选择和应用

* 性能角度考虑，尽量选择普通索引

* 所有更新后面都跟着数据的查询，应该关闭change buffer

* 如果读少的库，change buffer应该火力全开，最大是buffer pool的50%

  

### 数据库选择索引的机制

优化器判断因素：

#### 扫描行数

* 一个索引上不同的值越多，这个索引的区分度就越好。一个索引上不同值的个数叫做**基数**

* mysql通过采样随机取出N个数据页进行分析，然后进行计算。
* 当变更数据行操作1/M的时候，会自动触发统计
* 回表

```
# on 统计信息持久储存 N 20 M 10
# off 储存在内存中 N 8 M 16
innodb_stats_persistent [on|off]
```

有时侯对扫描行树错误的判断，会导致优化器选择索引错误。

```
全表扫描聚集索引的数据行数
普通索引 show table status
```

#### 是否使用临时表

#### 是否排序

临时表>排序>扫描行数

 解决方案

* Force index 强制选择索引
* analyze # 重新统计扫描行数
* 修改语句改变mysql的索引使用
* 新建一个合适的索引或者删掉不用的索引

