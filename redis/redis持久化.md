我们经常把redis当作缓存数据库使用，这时就会有一个重要的问题，一但redis服务器宕机，内存中的数据将全部丢失。最直观且保底的方案就是从mysql等数据库中恢复。但是直接从数据库中恢复存在两个问题

1.恢复期间会对数据库带来巨大的压力

2.影响用户体验，从数据库读取数据必然要慢很多

因此对于redis，进行数据的持久化，避免从后端恢复是至关重要的

### 一.redis持久化之AOF日志

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/54C1BDC8-6DBC-46D0-AA68-ABE8892737CF.png)

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/BD7E609F-1C45-4AD9-BADF-3DBC2741F563.png)

redis和其他数据不同的是先执行命令后写日志，传统的数据库日志比如redo log 记录的是修改后的数据，AOF记录的是Redis收到的每一条命令，这些命令是以文本形式保存的. 

1.为了避免额外的开销，redis在向AOF里面记录日志的时候，并不会先去对这些命令进行语法检查。所以先写日志就会有可能写入错误的记录

2.后写日志还可以避免对当前写操作的阻塞。

**AOF磁盘磁盘带来的问题**：

1.执行玩命令宕机，命令和相应的数据就会有丢失的风险

2.由于AOF在主线程中执行，如果在写入磁盘时，磁盘写压力大，就会阻塞下一个操作

**解决方案: redis提供了三个选择也就是appendfsync的三个可选值** 

```
Always:同步回写 每个命令执行完，立马同步地将日志写回磁盘

Everysec: 每秒写回 每个命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘

No: 操作系统控制的写回 每个写执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘

根据数据的安全性和性能进行权衡选择
```

**随着命令月来越多AOF文件会越来越大,随之带来问题:**

1.文件系统本身对文件的大小有限制，无法保存过大的文件

2.如果文件太大 , 之后追加记录的效率也会变低

3.宕机恢复过程缓慢

**解决方案（AOF重写机制）: **

在重写时，redis根据数据库的现状创建一个新的AOF文件，对每一个键值对用一条命令记录它的写入。将就日志文件中的多条命令变为一条。

**AOF不会阻塞主线程，重写过程是由后台线程bgrewriteaof完成**

重写过程“一个拷贝，两个日志”

一个拷贝: 每次执行重写时，主线程fork出后台的bgrewriteaof子进程。此时，fork会把主线程的内存拷贝给bg子进程，这里包含了数据库的最新数据。然后bg子进程就可以在不影响主线程的情况下，把数据写成操作，计入重写日志

两处日志：

第一处日志是正在使用的AOF日志，redis 会把这个操作写到它的缓冲区。这样保证宕机数据的正常恢复

第二处日志是重写日志，新的操作也写入重写日志的缓冲区，以保证一直记录的是数据的最新状态

方法:

**人工执行** :

```
bgrewriteaof
```

**相关配置**:

```
appendonly yes
appendfsync always|everysec|no

auto-aof-rewrite-percentage 100  # 指当前aof文件比上次重写的增长比例大小，达到这个大小就进行 aof 重写
auto-aof-rewrite-min-size 64mb  # 最开始aof文件必须要达到这个文件时才触发，后面的每次重写就不会根据这个变量了
```



### 二.redis持久化之RDB快照

AOF记录的是操作就不可避免的产生大量日志，宕机恢复就会变得很慢。所以就产生了内存快照RDB

RDB是全量快照，也就是把某一时刻内存中数据都记录在内存中。

Redis提供了两个命令来生成RDB文件，分别是**save**和**bgsave**

* Save: 在主线程中执行，会导致阻塞
* Bgsave: 创建一个子进程，专门用于写入RDB文件，避免了主线程的阻塞。这也是Redis RDB 文件生成的默认配置

**这样会带来一个新的问题执行快照时 写入了新的数据怎么办？**

Redis借助操作系统提供的写时复制技术Copy-On-write cow, 在执行快照的同时，正常处理写操作。

bgsave共享主线程的所有内存数据。当有新的数据写入时，这块数据就会被复制一份，生成该数据的副本。然后bgsave子进程会把这个副本写入RDB文件

实际操作方法:

人工操作:save， bgsave

相关配置:

```
save 900 1 # 900s 至少有一个键被改动
save 300 10 # 300s 10个
save 60 10000
```

**对比AOF,快照的恢复速度快但是频率不好把握，频率太低数据的安全性得不到保证两次快照间发生宕机。频率太高又会带来额外的开销(fork子进程,磁盘读写压力)**

redis4.0提出了混合使用AOF和RDB的方法。快照以一定的频率执行，在快照之间使用AOF记录操作。

这样既避免了频繁RDB也减少了AOF重写的次数

```
config set aof-use-rdb-preamble yes
```

具体操作相关博客：

https://blog.csdn.net/liuxingxing_star/article/details/104227255