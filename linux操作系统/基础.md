## 多进程

### 进程间通信IPC inter-process communication

#### 基于通信的IPC

数据传送（管道（pipe）-传输字节流，消息队列-结构化数据），共享内存（共享内存区）

#### 基于信号的IPC

操作系统的信号single

#### 基于同步的IPC

信号量 semaphore

### 进程

定义：所有代码都在进程中执行，是描述程序的执行过程，是一种动态概念。此外还是操作系统分配资源的一个基本单位；

子进程：通过调用fork（一个系统函数），可以创建出N个新的进程，会获得父进程数据段，堆和栈的副本，并共享代码段。

同样有进程的特性，子进程的操作对父进程和兄弟都是不可见的。

```
pid := os.Getpid() 查看进程id
ppid := os.Getpid() 查看父进程id
```

### 进程的状态

#### 可运行 R

立刻马上要或者正在cpu上运行

#### 可中断的睡眠 S

等待事件（网络连接，信号量）的来临，会被放入事件队列中

#### 不可中断的睡眠 D 

不会对任何信号作出响应，等待一个特殊事件 比如等待磁盘IO

#### 暂停或者跟踪状态 T

发送SINSTOP进入暂停 SINCONT 恢复；跟踪略

#### 僵尸 Z

即将结束运行，大部分资源已经被回收。该进程的父进程可能还需要它所以没有删除

#### 退出 X

父进程忽略SIGCHLD，进程已经分离  见（p51）

### 进程的空间

操作系统将内存划分为内核空间和用户空间。

进程生存在用户空间，无法和硬件进行直接交互。

用户内存区域中的每一个单元都是有地址的，由指针来标识和定位是虚拟地址，也是虚拟内存，虚拟内存会映射到物理内存上。

内核为每个进程的用户空间是相互独立的。

#### 物理内存和虚拟内存的联系

内核会把进程的虚拟内存划分为若干页（page）。

cpu划分物理内存，一个物理内存单元叫做一个页框（page frame）。

大部分情况下页和页框一一相对应，共享页框也是被允许的 （正是共享内存区的基础----IPC）

### 系统调用

System call函数是内核和用户空间唯一的桥梁

为了系统的安全绝大多数时间内核都处于用户态，用户空间发起系统调用，内核切换为内核态进行处理之后再切换回用户态。

### 进程切换

CPU会在多个进程间切换，切换时保存进程的上下文，涉及到IO操作

## 同步 

**竞态：**进程之间的混乱调度会造成对资源的竞争

**解决方案**：

* 原子操作-执行操作中不能内中断的操作（只支持一些简单操作，由单一的汇编指令表示）
* 临界区-只能被串行化访问或执行的某个资源或某段代码

串行化执行的若干代码形成临界区的做法更加通用。这个也叫**互斥（mutex）**

IPC方法之一的**信号量**就属于这个

```
待解决疑惑信号量到底是个啥
```

## 管道

管道是一种半双工（或者单向的）通信方式，只能用于父进程与子进程间以及祖先进程间的通信

ps aux |grep "xxx"

## 信号

是IPC通信中唯一一种异步的通信方式，本质是用软件模拟硬件的中断机制。信号用来通知某个进程有某个事件发生了

SIGKILL SIGSTOP不能被自行处理

## socket

一种IPC方法 通过网络连接让多个进程进行通信，使得通信端的位置透明化

## 五种IO模型

* 进程都必须在同一个通信域下 IPV4,IPV6,Unix域（同一个机器）
* 

