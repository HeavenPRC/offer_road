## OS

#### 1.五种IO模型

阻塞IO，非阻塞IO，IO多路复用，信号驱动式IO，异步非阻塞IO

**阻塞IO**：如果accept队列为空，导致用户进程sleep，交出cpu，发生进程间切换

**非阻塞IO**：如果accept队列为空，内核收到系统调用，再收到进程的read操作后，未完成不会阻塞会返回一个error；用户进程需要不断的主动询问kernel数据准备好了没有；不会交出CPU，造成严重的资源耗费

**IO多路复用：**select，poll，epoll 一个线程保存多个socket，轮询监控读写IO。虽然会发生阻塞但不会阻塞在io上，是阻塞在函数上。一个socket的阻塞不会影响其他的socket的Io读写。

最大的优势是：一个用户线程监控多个socket io

**信号驱动式IO：**首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，用户进程再调用I/O操作函数处理数据。

**异步非阻塞IO：**异步IO不是顺序执行。`用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情`。等到socket数据准备好了，内核直接复制数据给进程无序用户进程调用IO操作，`然后从内核向进程发送通知`。`IO两个阶段，进程都是非阻塞的`。

#### 2.select/poll/epoll的区别

|              | select                                                       | poll                   | epoll                                       |
| ------------ | ------------------------------------------------------------ | ---------------------- | ------------------------------------------- |
| 打开句柄数量 | 句柄集合是一个数据，调用select需要全部拷贝，内核做了限制1024 | 用链表储存没有大小限制 | 一个文件描述符管理多个描述符,数量远大于1024 |
| 内存         | 每次调用select，都需要把`fd_set`集合从用户态拷贝到内核       | 和select一样           | Mmap内存映射和内核共用一块内存              |
| 操作         | 内核要对所有fd_set进行遍历，如果`fd_set`集合很大时，那这个开销也很大， | 和select一样           | 活跃的socket才会触发                        |

## 网络

#### 1. 常用状态码

301 永久重定向

302 重定向，禁止缓存

401（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应

403  （禁止） 服务器拒绝请求。-权限校验

500 服务内部发生错误-服务发生错误

503 服务暂时不可用-发生在nginx限流

## 数据结构（融化于各个细节中）

## 算法

## Nginx

#### 1.nginx如何处理一个请求

首先，nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在nginx的master进程里面，先初始化好这个监控的socket(创建socket，设置addrreuse等选项，绑定到指定的ip地址端口，再listen)，然后再fork(一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程 )出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向nginx发起连接了。当客户端与nginx进行三次握手，与nginx建立好一个连接后，此时，某一个子进程会accept成功，得到这个建立好的连接的socket，然后创建nginx对连接的封装，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，nginx或客户端来主动关掉连接，到此，一个连接就寿终正寝了。

　　当然，nginx也是可以作为客户端来请求其它server的数据的（如upstream模块），此时，与其它server创建的连接，也封装在ngx_connection_t中。作为客户端，nginx先获取一个ngx_connection_t结构体，然后创建socket，并设置socket的属性（ 比如非阻塞）。然后再通过添加读写事件，调用connect/read/write来调用连接，最后关掉连接，并释放ngx_connection_t。

　　nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。并且，nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。

　　在这里，很多人会误解worker_connections这个参数的意思，认为这个值就是nginx所能建立连接的最大值。其实不然，这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。

## Redis

##### 1.Redis 缓存具体是怎么工作的？
##### 2.Redis 缓存如果满了，该怎么办？
##### 3.为什么会有缓存一致性、缓存穿透、缓存雪崩、缓存击穿等异常，该如何应对？
##### 4.Redis 的内存毕竟有限，如果用快速的固态硬盘来保存数据，可以增加缓存的数据量，那么，Redis 缓存可以使用快速固态硬盘吗？

##### 5.Redis连接过高有1w个连接

1.redis默认可以打来1w的连接，修改相关配置项,然后平滑重启

```
cd /usr/local/redis/bin 必须进入bin文件
./redis-server /usr/local/redis/etc/redis.conf  配置文件来启动Redis 服务
./redis-cli 启动客服端
127.0.0.1:6379>这个就代表进来了
debug reload 平滑重启
如果有密码就输入密码，密码忘记了就去Redis配置文件找
```

2.查看是否时空闲连接过多不释放

查看链接状态

```
redis-cli client list

addr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client
addr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping
```

查看配置

```
redis-cli config get timeout
```

配置空闲清理

```
redis-cli config set timeout 600
```

3.修改业务代码使用连接池，避免每一个命令打开一个连接或者使用完后主动关闭

## Go&PHP

## 系统设计

其实就是围绕业务实现，容灾方案，模块化设计，服务监控这几方面说就行