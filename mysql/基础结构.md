### mysql基础架构

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/0d2070e8f84c4801adbfa03bda1f98d9.png)

## server层

**Server**层 包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

### 连接器

连接器负责跟客户端建立连接，获取权限，维持和管理连接

```
mysql -h$ip -P$port -u$user -p
```

* 用户名密码不对，会收到一个“Access denied for user”的错误,客户端程序结束执行
* 用户名密码通过，连接器会在权限表里查出账户拥有的权限。之后这个连接里的权限操作都将依赖这个信息。（对权限进行修改后也需要重新建立连接才生效）

* 连接完成后无后续动作，这个连接就处于空闲状态

  可以**show processlist** 命令中看到。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。

  客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 **wait_timeout** 控制的，默认值是 8 小时。

  ![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/4ED753E2-910F-42FD-A5BD-640D19114906.png)

如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：**Lost connection to MySQL server during query**。这时候如果你要继续，就需要重连，然后再执行请求了。

#### 长连接和短连接

* **数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。**

* **短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。**

建立连接的过程很复杂，尽量使用长连接

**使用长连接可能会遇到的问题:**

但是全部使用长连接后，可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 **MySQL 在执行过程中临时使用的内存是管理在连接对象里面的**。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

**解决方案:**

1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后断开连接，之后查询重新连接

2.每次执行一个大的操作后，通过执行**mysql_reset_connection**（版本5.7以）来重新初始化连接资源。这个过程不需要重新初始化连接资源，只是会将连接恢复到刚刚创建完成时的状态

### 查询缓存

建立连接完成，mysql拿到请求，会先查询缓存。之前执行过的语句和结果可能会以key-value对的形式，被直接缓存在内存中，如果命中直接返回；

但是一般不建议使用，只要有一条数据更新整个表缓存都会被更新

8.0更是将功能整块删除

### 分析器

先对sql进行词法分析（每个词代表什么含义），再进行语法分析（是否满足mysql语法）。

### 优化器

优化器-决定使用的索引｜连表顺序

### 执行器

执行语句

1.判断表权限

2.

* 无索引:
  1.调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
  2.调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
  3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

* 有索引:

  执行的逻辑差不多。

  第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。
  你会在数据库的慢查询日志中看到一个 **rows_examined (在执行器每次调用引擎获取数据行的时候累加的)的字段**，表示这个语句执行过程中扫描了多少行。
  在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的

  

## 储存引擎层

**存储引擎层**负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

```
engine=memory # 指定储存引擎创建表
```

### InnoDB

在整个数据库体系结构中，我们可以使用不同的存储引擎来存储数据，而绝大多数存储引擎都以二进制的形式存储数据。

在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）、行（row）：

![avatar](https://image-stu.oss-cn-beijing.aliyuncs.com/20181204093045330.png)

**同一个数据库实例的所有表空间大小都有相同的页大小**

默认情况下，表空间中的页大小都为 **16KB**，当然也可以通过改变 **innodb_page_size** 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同

每一次IO读取是一个磁盘数据块也就是一页数据

### 随机读取和顺序读取

**单次从磁盘读取单位是页**，而不是行，也就是说，你即便只读取一行记录，从磁盘中也是会读取一页的，当然了单页读取代价也是蛮高的，一般都会进行**预读**，这些后续再说。

![avatar](https://img-blog.csdnimg.cn/20181204093214562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6dElzR29vZA==,size_16,color_FFFFFF,t_70)

关系型数据库管理系统最重要的一个目标就是，确保表或者索引中的数据是随时可以用的。那么为了尽可能的实现这个目标，会使用内存中的缓冲池来最小化磁盘活动。

每一个缓冲池都足够大，大到可以存放许多页，可能成千上万。

缓冲池管理器将尽力确保经常使用的数据被保存于池中，以避免一些不必要的磁盘读。

如果一个索引或者表页在缓冲池中，处理速度便会很快。

如果在缓冲池中，没有找到数据，会从磁盘服务器的缓冲区里面去读取。

磁盘服务器的缓冲区，如同数据库的缓冲池读取一样，磁盘服务器试图将频繁使用的数据保留在内存中，以降低高昂的磁盘读取成本。这个读取成本大概会在1ms左右。

如果磁盘服务器的缓冲池中依然没有找到数据，此时就必须要从磁盘读取了，此时读取又分区**随机读取**和**顺序读取**。

#### 随机I/O

一个页包含了多条记录，我们可能需要该页上的所有行或者一部分或者是一行，但所花费的成本都是相同的，读取一个页，需要一次随机I/O,大约需要10ms的时间。

![avatar](https://img-blog.csdnimg.cn/20181204093253388.png)

![avatar](https://img-blog.csdnimg.cn/20181204093303605.png) 

#### 顺序读取

如果我们需要将多个页读取到缓冲池中，并按顺序处理它们，此时读取的速度回变的很快，具体的原理，在B树索引中也有过介绍，此时读取每个页面（4kb）所花费的时间大概为0.1ms左右，这个时间消耗对随机IO有很大的优势。

**以下几种情况，会对数据进行顺序读取**

```
全表扫描 、全索引扫描、索引片扫描、 通过聚蔟索引扫描表行
```

**顺序读取有两个重要的优势：**

同时读取多个页意味着平均读取每个页的时间将会减少。在当前磁盘服务器条件下，对于4kb大小的页而言，这一值可能会低于0.1ms（40MB/s）
由于数据库引擎知道需要读取哪些页，所有可以在页被真正请求之前就提前将其读取进来，我们称为**预读**

### 最大与最小（数据库的阀值）

1. 一个表里最多可有1017列（在MySQL 5.6.9 之前最大支持1000列）。虚拟列也受限这个限制。
2. 一个表最多可以有64个二级索引。
3. 如果innodb_large_prefix打开，在InnoDB表DYNAMIC或COMPRESSED列格式下，索引前缀最大支持前3072字节；如果不打开的话，在任意列格式下，最多支持前767字节。这个限制既适用于前缀索引也适用于全列索引。
   基于一个16KB的页最多装3072个字节，如果你把InnoDB 的page 大小从8KB降到4KB，索引的长度也相应的降低。也就是说，当页是8KB的时候最大索引长度是1536字节；当页大小是4KB的时候最大索引长度是768字节;（

​       这里与“紧凑冗余行有关系”

```
当为外部页外存储选择可变长度列时InnoDB，将该行中的前768个字节存储在本地，其余外部存储到溢出页中。每个这样的列都有自己的溢出页列表。768字节的前缀伴随着一个20字节的值，该值存储列的真实长度并指向溢出列表，其中存储了值的其余部分。请参见 第14.11节“InnoDB行格式”。
```

​     联合索引最多支持16列，如果超过这个限制就会遇到以下错误：

```
ERROR 1070 (42000): Too many key parts specified; max 16 parts allowed
```

4. （除去可变长类型：VARBINARY/VARCHAR/BLOB/TEXT），要小于页长（如4KB, 8KB, 16KB, and 32KB）的一半。例如：innodb_page_size 长度是16KB的话，行长不超过8KB；如果innodb_page_size 是64KB的话，行长不超过16KB； LONGBLOB/LONGTEXT/BLOB/TEXT列必须小于4GB，整个行长也必须小于4GB。如果一行小于一页的一半，它可以存在一个page里面。如果超过了页的一半，就会把可变长列放到额外的页存（如果对这个感兴趣的话可以看看，MySQL页管理）。

5. 行所存储的值的最大值为页的大小的一半，一般情况下页的大小是16kB，所以每行的长度大小不能超过8
   kb；2的16次刚好为65535；

